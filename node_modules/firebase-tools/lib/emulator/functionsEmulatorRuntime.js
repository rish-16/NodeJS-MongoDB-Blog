"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const functionsEmulatorShared_1 = require("./functionsEmulatorShared");
const express = require("express");
const child_process_1 = require("child_process");
const path = require("path");
const bodyParser = require("body-parser");
const types_2 = require("./events/types");
const url_1 = require("url");
let app;
let adminModuleProxy;
function slowRequireResolve(moduleName, cwd) {
    const resolver = `console.log(require.resolve("${moduleName}"))`;
    const result = child_process_1.spawnSync(process.execPath, ["-e", resolver], {
        cwd: path.resolve(cwd || process.cwd()),
    });
    return result.stdout.toString().trim();
}
class Proxied {
    constructor(original) {
        this.original = original;
        this.rewrites = {};
        this.proxy = new Proxy(this.original, {
            get: (target, key) => {
                key = key.toString();
                if (this.rewrites[key]) {
                    return this.rewrites[key](target, key);
                }
                if (this.anyValue) {
                    return this.anyValue(target, key);
                }
                return this.getOriginal(target, key);
            },
            apply: (target, thisArg, argArray) => {
                if (this.appliedValue) {
                    return this.appliedValue.apply(thisArg, argArray);
                }
                else {
                    return this.applyOriginal(target, thisArg, argArray);
                }
            },
        });
    }
    when(key, value) {
        this.rewrites[key] = value;
        return this;
    }
    any(value) {
        this.anyValue = value;
        return this;
    }
    applied(value) {
        this.appliedValue = value;
        return this;
    }
    getOriginal(target, key) {
        const value = target[key];
        if (!isExists(value)) {
            return undefined;
        }
        else if (isConstructor(value) || typeof value !== "function") {
            return value;
        }
        else {
            return value.bind(target);
        }
    }
    applyOriginal(target, thisArg, argArray) {
        return target.apply(thisArg, argArray);
    }
    finalize() {
        return this.proxy;
    }
}
function isConstructor(obj) {
    return !!obj.prototype && !!obj.prototype.constructor.name;
}
function isExists(obj) {
    return obj !== undefined;
}
function verifyDeveloperNodeModules(frb) {
    let pkg;
    try {
        pkg = require(`${frb.cwd}/package.json`);
    }
    catch (err) {
        new types_1.EmulatorLog("SYSTEM", "missing-package-json", "").log();
        return false;
    }
    const modBundles = [
        { name: "firebase-admin", isDev: false, minVersion: 7 },
        { name: "firebase-functions", isDev: false, minVersion: 2 },
        { name: "firebase-functions-test", isDev: true, minVersion: 0 },
    ];
    for (const modBundle of modBundles) {
        const dependencies = pkg.dependencies || {};
        const devDependencies = pkg.devDependencies || {};
        const isInPackageJSON = dependencies[modBundle.name] || devDependencies[modBundle.name];
        if (!isInPackageJSON) {
            new types_1.EmulatorLog("SYSTEM", "missing-module", "", modBundle).log();
            return false;
        }
        let modResolution;
        try {
            modResolution = slowRequireResolve(modBundle.name, frb.cwd);
        }
        catch (err) {
            new types_1.EmulatorLog("SYSTEM", "uninstalled-module", "", modBundle).log();
            return false;
        }
        const modPackageJSON = require(path.join(functionsEmulatorShared_1.findModuleRoot(modBundle.name, modResolution), "package.json"));
        const modMajorVersion = parseInt((modPackageJSON.version || "0").split("."), 10);
        if (modMajorVersion < modBundle.minVersion) {
            new types_1.EmulatorLog("SYSTEM", "out-of-date-module", "", modBundle).log();
            return false;
        }
    }
    return true;
}
function InitializeNetworkFiltering(frb) {
    const networkingModules = [
        { name: "http", module: require("http"), path: ["request"] },
        { name: "http", module: require("http"), path: ["get"] },
        { name: "https", module: require("https"), path: ["request"] },
        { name: "https", module: require("https"), path: ["get"] },
        { name: "net", module: require("net"), path: ["connect"] },
    ];
    try {
        const gcFirestore = functionsEmulatorShared_1.findModuleRoot("@google-cloud/firestore", slowRequireResolve("@google-cloud/firestore", frb.cwd));
        const gaxPath = slowRequireResolve("google-gax", gcFirestore);
        const gaxModule = {
            module: require(gaxPath),
            path: ["GrpcClient"],
            name: "google-gax",
        };
        networkingModules.push(gaxModule);
        new types_1.EmulatorLog("DEBUG", "runtime-status", `Found google-gax at ${gaxPath}`).log();
    }
    catch (err) {
        new types_1.EmulatorLog("DEBUG", "runtime-status", `Couldn't find google-cloud/firestore or google-gax`).log();
    }
    const history = {};
    const results = networkingModules.map((bundle) => {
        let obj = bundle.module;
        for (const field of bundle.path.slice(0, -1)) {
            obj = obj[field];
        }
        const method = bundle.path.slice(-1)[0];
        const original = obj[method].bind(bundle.module);
        obj[method] = function (...args) {
            const hrefs = args
                .map((arg) => {
                if (typeof arg === "string") {
                    try {
                        const _ = new url_1.URL(arg);
                        return arg;
                    }
                    catch (err) {
                        return;
                    }
                }
                else if (typeof arg === "object") {
                    return arg.href;
                }
                else {
                    return;
                }
            })
                .filter((v) => v);
            const href = (hrefs.length && hrefs[0]) || "";
            if (href && !history[href]) {
                history[href] = true;
                if (href.indexOf("googleapis.com") !== -1) {
                    new types_1.EmulatorLog("SYSTEM", "googleapis-network-access", "", {
                        href,
                        module: bundle.name,
                    }).log();
                }
                else {
                    new types_1.EmulatorLog("SYSTEM", "unidentified-network-access", "", {
                        href,
                        module: bundle.name,
                    }).log();
                }
            }
            try {
                return original(...args);
            }
            catch (e) {
                const newed = new original(...args);
                if (bundle.name === "google-gax") {
                    const cs = newed.constructSettings;
                    newed.constructSettings = (...csArgs) => {
                        csArgs[3].authorization = "Bearer owner";
                        return cs.bind(newed)(...csArgs);
                    };
                }
                return newed;
            }
        };
        return { name: bundle.name, status: "mocked" };
    });
    new types_1.EmulatorLog("DEBUG", "runtime-status", "Outgoing network have been stubbed.", results).log();
}
function InitializeFirebaseFunctionsStubs(functionsDir) {
    const firebaseFunctionsResolution = slowRequireResolve("firebase-functions", functionsDir);
    const firebaseFunctionsRoot = functionsEmulatorShared_1.findModuleRoot("firebase-functions", firebaseFunctionsResolution);
    const httpsProviderResolution = path.join(firebaseFunctionsRoot, "lib/providers/https");
    const httpsProvider = require(httpsProviderResolution);
    const _onRequestWithOpts = httpsProvider._onRequestWithOpts;
    httpsProvider._onRequestWithOpts = (handler, opts) => {
        const cf = _onRequestWithOpts(handler, opts);
        cf.__emulator_func = handler;
        return cf;
    };
    httpsProvider.onRequest = (handler) => {
        return httpsProvider._onRequestWithOpts(handler, {});
    };
}
function InitializeFirebaseAdminStubs(frb) {
    const adminResolution = slowRequireResolve("firebase-admin", frb.cwd);
    const grpc = require(slowRequireResolve("grpc", frb.cwd));
    const localAdminModule = require(adminResolution);
    let hasInitializedSettings = false;
    const initializeSettings = (userSettings) => {
        const isEnabled = isFeatureEnabled(frb, "admin_stubs");
        if (!isEnabled) {
            if (!hasInitializedSettings) {
                app.firestore().settings(userSettings);
                hasInitializedSettings = true;
            }
            return;
        }
        if (!hasInitializedSettings && frb.ports.firestore) {
            app.firestore().settings(Object.assign({ projectId: frb.projectId, port: frb.ports.firestore, servicePath: "localhost", service: "firestore.googleapis.com", sslCreds: grpc.credentials.createInsecure() }, userSettings));
        }
        else if (!frb.ports.firestore && frb.triggerId) {
            new types_1.EmulatorLog("WARN", "runtime-status", "The Cloud Firestore emulator is not running so database operations will fail with a " +
                "'default credentials' error.").log();
        }
        hasInitializedSettings = true;
    };
    adminModuleProxy = new Proxied(localAdminModule)
        .when("initializeApp", (adminModuleTarget) => (opts, appName) => {
        if (appName) {
            new types_1.EmulatorLog("SYSTEM", "non-default-admin-app-used", "", { appName }).log();
            return adminModuleTarget.initializeApp(opts, appName);
        }
        new types_1.EmulatorLog("SYSTEM", "default-admin-app-used", "").log();
        app = adminModuleTarget.initializeApp(Object.assign({}, JSON.parse(process.env.FIREBASE_CONFIG || "{}"), opts));
        return app;
    })
        .when("firestore", (adminModuleTarget) => {
        const proxied = new Proxied(adminModuleTarget.firestore);
        return proxied
            .applied(() => {
            return new Proxied(adminModuleTarget.firestore())
                .when("settings", () => {
                return (settings) => {
                    initializeSettings(settings);
                };
            })
                .any((target, field) => {
                initializeSettings({});
                return proxied.getOriginal(target, field);
            })
                .finalize();
        })
            .finalize();
    })
        .finalize();
    require.cache[adminResolution] = {
        exports: adminModuleProxy,
    };
    new types_1.EmulatorLog("DEBUG", "runtime-status", "firebase-admin has been stubbed.", {
        adminResolution,
    }).log();
    return adminModuleProxy;
}
function ProtectEnvironmentalVariables() {
    process.env.GOOGLE_APPLICATION_CREDENTIALS = "";
}
function InitializeEnvironmentalVariables(projectId) {
    process.env.GCLOUD_PROJECT = projectId;
    process.env.FIREBASE_CONFIG = JSON.stringify({
        databaseURL: process.env.DATABASE_URL || `https://${process.env.GCLOUD_PROJECT}.firebaseio.com`,
        storageBucket: process.env.STORAGE_BUCKET_URL || `${process.env.GCLOUD_PROJECT}.appspot.com`,
        projectId: process.env.GCLOUD_PROJECT,
    });
}
function InitializeFunctionsConfigHelper(functionsDir) {
    const functionsResolution = slowRequireResolve("firebase-functions", functionsDir);
    const ff = require(functionsResolution);
    new types_1.EmulatorLog("DEBUG", "runtime-status", "Checked functions.config()", {
        config: ff.config(),
    }).log();
    const originalConfig = ff.config();
    const proxiedConfig = new Proxied(originalConfig)
        .any((parentConfig, parentKey) => {
        new types_1.EmulatorLog("DEBUG", "runtime-status", "config() parent accessed!", {
            parentKey,
            parentConfig,
        }).log();
        return new Proxied(parentConfig[parentKey] || {})
            .any((childConfig, childKey) => {
            const value = childConfig[childKey];
            if (value) {
                return value;
            }
            else {
                const valuePath = [parentKey, childKey].join(".");
                new types_1.EmulatorLog("SYSTEM", "functions-config-missing-value", "", { valuePath }).log();
                return undefined;
            }
        })
            .finalize();
    })
        .finalize();
    ff.config = () => proxiedConfig;
}
function ProcessHTTPS(frb, trigger) {
    return __awaiter(this, void 0, void 0, function* () {
        const ephemeralServer = express();
        const socketPath = functionsEmulatorShared_1.getTemporarySocketPath(process.pid);
        yield new Promise((resolveEphemeralServer, rejectEphemeralServer) => {
            const handler = (req, res) => __awaiter(this, void 0, void 0, function* () {
                try {
                    new types_1.EmulatorLog("DEBUG", "runtime-status", `Ephemeral server used!`).log();
                    const func = trigger.getRawFunction();
                    res.on("finish", () => {
                        instance.close();
                        resolveEphemeralServer();
                    });
                    yield RunHTTPS([req, res], func);
                }
                catch (err) {
                    rejectEphemeralServer(err);
                }
            });
            ephemeralServer.use(bodyParser.json({}));
            ephemeralServer.use(bodyParser.text({}));
            ephemeralServer.use(bodyParser.urlencoded({ extended: true }));
            ephemeralServer.use(bodyParser.raw({ type: "*/*" }));
            ephemeralServer.get("/*", handler);
            ephemeralServer.post("/*", handler);
            const instance = ephemeralServer.listen(socketPath, () => {
                new types_1.EmulatorLog("SYSTEM", "runtime-status", "ready", { socketPath }).log();
            });
        });
    });
}
function ProcessBackground(frb, trigger) {
    return __awaiter(this, void 0, void 0, function* () {
        new types_1.EmulatorLog("SYSTEM", "runtime-status", "ready").log();
        let proto = frb.proto;
        const service = functionsEmulatorShared_1.getFunctionService(trigger.definition);
        if (service === "firestore.googleapis.com") {
            if (types_2.EventUtils.isEvent(proto)) {
                const legacyProto = types_2.EventUtils.convertToLegacy(proto);
                new types_1.EmulatorLog("DEBUG", "runtime-status", `[firestore] converting to a v1beta1 event: old=${JSON.stringify(proto)}, new=${JSON.stringify(legacyProto)}`).log();
                proto = legacyProto;
            }
            else {
                new types_1.EmulatorLog("DEBUG", "runtime-status", `[firestore] Got legacy proto ${JSON.stringify(proto)}`).log();
            }
        }
        yield RunBackground(proto, trigger.getRawFunction());
    });
}
function Run(func) {
    return __awaiter(this, void 0, void 0, function* () {
        const log = console.log;
        console.log = (...messages) => {
            new types_1.EmulatorLog("USER", "function-log", messages.join(" ")).log();
        };
        let caughtErr;
        try {
            yield func();
        }
        catch (err) {
            caughtErr = err;
        }
        console.log = log;
        new types_1.EmulatorLog("DEBUG", "runtime-status", `Ephemeral server survived.`).log();
        if (caughtErr) {
            throw caughtErr;
        }
    });
}
function RunBackground(proto, func) {
    return __awaiter(this, void 0, void 0, function* () {
        new types_1.EmulatorLog("DEBUG", "runtime-status", `RunBackground: proto=${JSON.stringify(proto)}`).log();
        yield Run(() => {
            return func(proto);
        });
    });
}
function RunHTTPS(args, func) {
    return __awaiter(this, void 0, void 0, function* () {
        if (args.length < 2) {
            throw new Error("Function must be passed 2 args.");
        }
        yield Run(() => {
            return func(args[0], args[1]);
        });
    });
}
function isFeatureEnabled(frb, feature) {
    return frb.disabled_features ? !frb.disabled_features[feature] : true;
}
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        const serializedFunctionsRuntimeBundle = process.argv[2] || "{}";
        const serializedFunctionTrigger = process.argv[3];
        new types_1.EmulatorLog("DEBUG", "runtime-status", "Functions runtime initialized.", {
            cwd: process.cwd(),
            node_version: process.versions.node,
        }).log();
        const frb = JSON.parse(serializedFunctionsRuntimeBundle);
        if (frb.triggerId) {
            new types_1.EmulatorLog("INFO", "runtime-status", `Beginning execution of "${frb.triggerId}"`, {
                frb,
            }).log();
        }
        new types_1.EmulatorLog("DEBUG", "runtime-status", `Disabled runtime features: ${JSON.stringify(frb.disabled_features)}`).log();
        const verified = verifyDeveloperNodeModules(frb);
        if (!verified) {
            new types_1.EmulatorLog("INFO", "runtime-status", `Your functions could not be parsed due to an issue with your node_modules (see above)`).log();
            return;
        }
        InitializeEnvironmentalVariables(frb.projectId);
        if (isFeatureEnabled(frb, "protect_env")) {
            ProtectEnvironmentalVariables();
        }
        if (isFeatureEnabled(frb, "network_filtering")) {
            InitializeNetworkFiltering(frb);
        }
        if (isFeatureEnabled(frb, "functions_config_helper")) {
            InitializeFunctionsConfigHelper(frb.cwd);
        }
        InitializeFirebaseFunctionsStubs(frb.cwd);
        InitializeFirebaseAdminStubs(frb);
        let triggers;
        const triggerDefinitions = [];
        let triggerModule;
        if (serializedFunctionTrigger) {
            triggerModule = eval(serializedFunctionTrigger)();
        }
        else {
            triggerModule = require(frb.cwd);
        }
        require("../extractTriggers")(triggerModule, triggerDefinitions);
        triggers = yield functionsEmulatorShared_1.getEmulatedTriggersFromDefinitions(triggerDefinitions, triggerModule);
        new types_1.EmulatorLog("SYSTEM", "triggers-parsed", "", { triggers, triggerDefinitions }).log();
        if (!frb.triggerId) {
            return;
        }
        if (!triggers[frb.triggerId]) {
            new types_1.EmulatorLog("FATAL", "runtime-status", `Could not find trigger "${frb.triggerId}" in your functions directory.`).log();
            return;
        }
        else {
            new types_1.EmulatorLog("DEBUG", "runtime-status", `Trigger "${frb.triggerId}" has been found, beginning invocation!`).log();
        }
        const trigger = triggers[frb.triggerId];
        new types_1.EmulatorLog("DEBUG", "runtime-status", "", trigger.definition).log();
        const mode = trigger.definition.httpsTrigger ? "HTTPS" : "BACKGROUND";
        new types_1.EmulatorLog("DEBUG", "runtime-status", `Running ${frb.triggerId} in mode ${mode}`).log();
        if (!app) {
            adminModuleProxy.initializeApp();
            new types_1.EmulatorLog("SYSTEM", "admin-auto-initialized", "").log();
        }
        let seconds = 0;
        const timerId = setInterval(() => {
            seconds++;
        }, 1000);
        let timeoutId;
        if (isFeatureEnabled(frb, "timeout")) {
            timeoutId = setTimeout(() => {
                new types_1.EmulatorLog("WARN", "runtime-status", `Your function timed out after ~${trigger.definition.timeout ||
                    "60s"}. To configure this timeout, see
      https://firebase.google.com/docs/functions/manage-functions#set_timeout_and_memory_allocation.`).log();
                process.exit();
            }, trigger.timeoutMs);
        }
        switch (mode) {
            case "BACKGROUND":
                yield ProcessBackground(frb, triggers[frb.triggerId]);
                break;
            case "HTTPS":
                yield ProcessHTTPS(frb, triggers[frb.triggerId]);
                break;
        }
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        clearInterval(timerId);
        new types_1.EmulatorLog("INFO", "runtime-status", `Finished "${frb.triggerId}" in ~${Math.max(seconds, 1)}s`).log();
    });
}
if (require.main === module) {
    main().catch((err) => {
        new types_1.EmulatorLog("FATAL", "runtime-error", err.stack ? err.stack : err).log();
        process.exit();
    });
}
//# sourceMappingURL=functionsEmulatorRuntime.js.map